There is always a little bit of boilerplate configuration in any Kafka Streams app, but three lines in this tutorial are worth comment. You don't have to do anything on this step, so you can come back to it later if you'd like.

First, the `TimestampExtractor` we created in the previous step is installed into our stream processing topology through a configuration setting. This is the `props.put(StreamsConfig.DEFAULT_TIMESTAMP_EXTRACTOR_CLASS_CONFIG, RatingTimestampExtractor.class.getName())` line.

Second, we want to optimize our Streams app for latency at the expense of throughput. (The real thing we want here is to see results in the output terminal pane as quickly as possible, which is a less-fancy way of saying the same thing.) To make this happen, we have to disable the Streams output cache as follows: `props.put(StreamsConfig.CACHE_MAX_BYTES_BUFFERING_CONFIG, 0)`.

Finally, we need to remeber that a Streams app caches its state locally on disk, in a directory pointed to by the `state.dir` configuration setting. If you run the application once, kill it, then run it again, it will likely find the state left on disk by the previous run. This is very much by design, but can be confusing when you're experimenting with a small tutorial like this. To make sure state goes into a throwaway temporary directory, we set the state dir with `props.put(StreamsConfig.STATE_DIR_CONFIG, Files.createTempDirectory("tumbling-windows").toAbsolutePath().toString())`. Note that the call must be wrapped in an exception-handling block, and if we fail to create the temporary directory, we continue running with the default directory in place.