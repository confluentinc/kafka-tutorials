<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">1. Get Confluent Platform</h4>

  <p>If you haven't already, get Confluent Platform.</p>
  <pre class="snippet"><code class="shell">{% include shared-content/docker-install.txt %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">2. Initialize the project</h4>

  <p>To get started, make a new directory anywhere you'd like for this project:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/init.sh %}</code></pre>

  <p>Create the following Gradle build file, named <code>build.gradle</code>:</p>
  <pre class="snippet"><code class="groovy">{% include_raw recipes/tumbling-windows/kstreams/code/build.gradle %}</code></pre>

  <p>And be sure to run the following command to obtain the Gradle wrapper:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/gradle-wrapper.sh %}</code></pre>

  <p>Next, create a directory for configuration data:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/make-configuration-dir.sh %}</code></pre>

  <p>Then create a development file at <code>configuration/dev.properties</code>:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/configuration/dev.properties %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">3. Create a schema for the events</h4>

  <p>This recipe uses a single input stream called <code>ratings</code>. It contains movie ratings for a few different movies submitted at times spanning a few weeks. We'll need to create a schema for these events.</p>
  
  <p>Create a directory to hold the schema file:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/make-avro-dir.sh %}</code></pre>

  <p>Next, create an Avro schema file at <code>src/main/avro/rating.avsc</code> for the stream of ratings:</p>
  <pre class="snippet"><code class="avro">{% include_raw recipes/tumbling-windows/kstreams/code/src/main/avro/rating.avsc %}</code></pre>

  <p>Because we will use this Avro schema in our Java code, we'll need to compile it. The Gradle Avro plugin is a part of the build, so it will see your new Avro files, generate Java code for them, and compile those and all other Java sources. Run this command to get it all done:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/build-project.sh %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">4. Create the Kafka Streams topology</h4>

  <p>Create a directory for the Java files in this project:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/make-src-dir.sh %}</code></pre>

  <p>Then create the following file at <code>src/main/java/io/confluent/developer/TumblingWindow.java</code>.</p>
    
  <pre class="snippet"><code class="java">{% include_raw recipes/tumbling-windows/kstreams/code/src/main/java/io/confluent/developer/TumblingWindow.java %}</code></pre>

  <p>Let's take a close look at the <code>buildTopology()</code> method, which uses the Kafka Streams DSL.</p>

  <p>The first thing the method does is create an instance of <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/StreamsBuilder.html">StreamsBuilder</a></code>, which is the helper object that lets us build our topology. 
  
  First, we call the <code>stream()</code> method to create a <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KStream.html">KStream</a><String, Rating></code> object. The problem is that we can't make any assumptions about the key of this stream, so we have to repartition it explicitly. We use the <code>map()</code> method for that, creating a new <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/KeyValue.html">KeyValue</a></code> instance for each record, using the title as the new key.</p>
    
  <p>Next we group the events by that new key by calling the <code>groupByKey()</code> method. We want to count the events that occur with each given key, so we must first define a tumbling window by calling <code>windowedBy(TimeWindows.of(Duration.ofMinutes(10)))</code>. We then call <code>count()</code>, which directs the topology to count the grouped events that occur within each window. At this point in the toplogy, the result is a <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html"></a>KTable</a><<a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/Windowed.html">Windowed</a><String>,Long></code>. We use the <code>map()</code> method to turn it into two easy-to-read strings, then emit the result to the output topic with the <code>to()</code> method. You might not always make that last call to <code>map()</code>, but for our purposes here, it makes the output a lot easier to read.</p>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">5. Implement a TimestampExtractor class</h4>

  <p>The preceding topology relies on the messages in its input topic being processed according <em>event time</em>â€”the time at which the event actually occurred, rather than the time it happened to arrive on the topic. Event time is typically available in the message itself, as it is in this case in the form of the <code>timestamp</code> field. We can automatically extract this timestamp by creating the <code>src/main/java/io/confluent/developer/RatingTimestampExtractor.java</code> class, which is an implementation of the <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/processor/TimestampExtractor.html">TimestampExtractor</a></code> interface. The code is simple:</p>

  <pre class="snippet"><code class="java">{% include_raw recipes/tumbling-windows/kstreams/code/src/main/java/io/confluent/developer/RatingTimestampExtractor.java %}</code></pre>

</div>


<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">6. Some special configuration</h4>
  <p>There is always a little bit of boilerplate configuration in any Kafka Streams app, but three lines in this recipe are worth comment. You don't have to do anything on this step, so you can come back to it later if you'd like.</p>

  <p>First, the <code>TimestampExtractor</code> we created in the previous step is installed into our stream processing topology through a configuration setting. This is the <code>props.put(StreamsConfig.DEFAULT_TIMESTAMP_EXTRACTOR_CLASS_CONFIG, RatingTimestampExtractor.class.getName())</code> line.</p>

  <p>Second, we want to optimize our Streams app for latency at the expense of throughput. (The real thing we want here is to see results in the output terminal pane as quickly as possible, which is a less-fancy way of saying the same thing.) To make this happen, we have to disable the Streams output cache as follows: <code>props.put(StreamsConfig.CACHE_MAX_BYTES_BUFFERING_CONFIG, 0)</code>  </p>

  <p>Finally, we need to remeber that a Streams app caches its state locally on disk, in a directory pointed to by the <code>state.dir</code> configuration setting. If you run the application once, kill it, then run it again, it will likely find the state left on disk by the previous run. This is very much by design, but can be confusing when you're experimenting with a small recipe like this. To make sure state goes into a throwaway temporary directory, we set the state dir with <code>props.put(StreamsConfig.STATE_DIR_CONFIG, Files.createTempDirectory("tumbling-windows").toAbsolutePath().toString())</code>. Note that the call must be wrapped in an exception-handling block, and if we fail to create the temporary directory, we continue running with the default directory in place.</p>
</div>


<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">7. Compile and run the Kafka Streams program</h4>

  <p>In your terminal, run:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/build-uberjar.sh %}</code></pre>

  <p>Now that you have an uberjar for the Kafka Streams application, you can launch it locally. When you run the following, the prompt won't return, because the application will run until you exit it. There is always another message to process, so streaming applications don't exit until you force them.</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/run-dev-app.sh %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">8. Get ready to observe the counted ratings in the output topic</h4>

  <p>Before you start producing input data, it's a good idea to set up the consumer on the output topic. This way, as soon as you produce movie ratings (and windowed and counted), you'll see the results right away. Run this to get ready to consume the windowed counts:</p>

  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/console-consumer.sh %}</code></pre>

  <p>You won't see any results until the next step.</p>

</div>


<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">9. Produce some ratings to the input topic</h4>

  <p>When the console producer starts, it will log some text and hang, waiting for your input. You can copy and paste all of the test data at once to see the results. (Because event times are baked into each message, it doesn't matter at what time the messages arrive in the input topic. In fact, if you want extra credit, you should be able to experiment with changing the order of the messages in this data, and still get the same output counts.)</p>

  <p>Start the console producer with this command in a terminal window of its own:</p>

  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/console-producer-ratings.sh %}</code></pre>

  <p>When the producer starts up, copy and paste these lines into the terminal:</p>
  <pre class="snippet"><code class="json">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/ratings.json %}</code></pre>

  <p>Looking back up in the consumer terminal, these are the results you should see there if you paste in all the ratings as directed above:</p>
  <pre class="snippet"><code class="json">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/windowed-counted-ratings.txt %}</code></pre>

  <p>Note that each event is counted individually. Since output caching is disabled, we see Die Hard get counted once, then counted again, then counted again, until the Die Hard ratings stop arriving. At that point, we have the final count for that movie. The same happens with all the rest. If we were to interrogate the contents of the resulting <code>KTable</code> after all the input messages have arrived, we would see only the final counts in the tableâ€”not the history of the counting as we see in the output topic. This is a good illustration of what we sometimes refer to as the <em>stream-table duality</em>.</p>

  <p>That is a topic for further study later on, but for now, you deserve some congratulations! You have now computed an aggregation over a tumbling window. Well done.</p>

</div>
