<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">1. Get Confluent Platform</h4>

  <p>If you haven't already, get Confluent Platform.</p>
  <pre class="snippet"><code class="shell">{% include shared-content/docker-install.txt %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">2. Initialize the project</h4>

  <p>To get started, make a new directory anywhere you'd like for this project:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/init.sh %}</code></pre>

  <p>Create the following Gradle build file, named <code>build.gradle</code>:</p>
  <pre class="snippet"><code class="groovy">{% include_raw recipes/tumbling-windows/kstreams/code/build.gradle %}</code></pre>

  <p>Next, create a directory for configuration data:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/make-configuration-dir.sh %}</code></pre>

  <p>Then create a development file at <code>configuration/dev.properties</code>:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/configuration/dev.properties %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">3. Create a schema for the events</h4>

  <p>This recipe uses a single input stream called <code>ratings</code>. It contains movie ratings for a few different movies submitted at times spanning a few weeks. We'll need to create a schema for these events.</p>
  
  <p>Create a directory to hold the schema file:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/make-avro-dir.sh %}</code></pre>

  <p>Next, create an Avro schema file at <code>src/main/avro/rating.avsc</code> for the stream of ratings:</p>
  <pre class="snippet"><code class="avro">{% include_raw recipes/tumbling-windows/kstreams/code/src/main/avro/rating.avsc %}</code></pre>

  <p>Because we will use this Avro schema in our Java code, we'll need to compile it. The Gradle Avro plugin is a part of the build, so it will see your new Avro files, generate Java code for them, and compile those and all other Java sources. Run this command to get it all done:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/joining/kstreams/code/recipe-steps/dev/build-project.sh %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">4. Create the Kafka Streams topology</h4>

  <p>Create a directory for the Java files in this project:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/joining/kstreams/code/recipe-steps/dev/make-src-dir.sh %}</code></pre>

  <p>Then create the following file at <code>src/main/java/io/confluent/developer/TumblingWindow.java</code>.</p>
    
  <pre class="snippet"><code class="java">{% include_raw recipes/tumbling-windows/kstreams/code/src/main/java/io/confluent/developer/TumblingWindow.java %}</code></pre>

  <p>Let's take a close look at the <code>buildTopology()</code> method, which uses the Kafka Streams DSL.</p>

  <p>The first thing the method does is create an instance of <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/StreamsBuilder.html">StreamsBuilder</a></code>, which is the helper object that lets us build our topology. 
  
  First, we call the <code>stream()</code> method to create a <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KStream.html">KStream</a><String, Rating></code> object. The problem is that we can't make any assumptions about the key of this stream, so we have to repartition it explicitly. We use the <code>map()</code> method for that, creating a new <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/KeyValue.html">KeyValue</a></code> instance for each record, using the title as the new key.</p>
    
  Next we group the events by that new key by calling the <code>groupByKey()</code> method. We want to count the events that occur with each given key, so we must first define a tumbling window by calling <code>windowedBy(TimeWindows.of(Duration.ofDays(1)))</code>. We then call <code>count()</code>, which directs the topology to count the grouped events that occur within each window. At this point in the toplogy, the result is a <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KTable.html"></a>KTable</a><<a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/Windowed.html">Windowed</a><String>,Long></code>. We use the <code>map()</code> method to turn in into two easy-to-read strings, then emit the result to the output topic with the <code>to()</code> method.
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">5. Implement a TimestampExtractor class</h4>

  <p>The preceding topology relies on the messages in its input topic being processed according <em>event time</em>â€”the time at which the event actually occurred, rather than the time it happened to arrive on the topic. Event time is typically available in the message itself, as it is in this case in the form of the <code>timestamp</code> field. We can automatically extract this timestamp by creating the <code>src/main/java/io/confluent/developer/RatingTimestampExtractor.java</code> class, which is an implementation of the <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/processor/TimestampExtractor.html">TimestampExtractor</a></code> interface. The code is simple:</p>

  <pre class="snippet"><code class="java">{% include_raw recipes/tumbling-windows/kstreams/code/src/main/java/io/confluent/developer/RatingTimestampExtractor.java %}</code></pre>

  <p>The TimestampExtractor is installed back up in the <code>TumblingWindow</code> class by way of a configuration setting. Look for the line <code>props.put(StreamsConfig.DEFAULT_TIMESTAMP_EXTRACTOR_CLASS_CONFIG, RatingTimestampExtractor.class.getName());</code> to see where it's done.</p>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">6. Compile and run the Kafka Streams program</h4>

  <p>In your terminal, run:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/build-uberjar.sh %}</code></pre>

  <p>Now that you have an uberjar for the Kafka Streams application, you can launch it locally. When you run the following, the prompt won't return, because the application will run until you exit it. There is always another message to process, so streaming applications don't exit until you force them.</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/run-dev-app.sh %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">7. Load in some reference data</h4>

  <p>In a new terminal, run:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/console-producer-ratings.sh %}</code></pre>

  <p>When the console producer starts, it will log some messages and hang, waiting for your input. Copy and paste one line at a time and press enter to send it. Note that these lines contain hard tabs between the key and the value, so retyping them without the tab will not work.</p> 

  <p>Each line represents a movie we will be able to rate. To send all of the events below, paste the following into the prompt and press enter:</p>
  <pre class="snippet"><code class="json">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/ratings.json %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">8. Get ready to observe the counted ratings in the output topic</h4>

  <p>Before you start producing ratings, it's a good idea to set up the consumer on the output topic. This way, as soon as you produce ratings (and they're joined to movies), you'll see the results right away. Run this to get ready to consume the rated movies:</p>

  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/console-consumer.sh %}</code></pre>

  <p>You won't see any results until the next step.</p>

</div>


<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">9. Produce some ratings to the input topic</h4>

  <p>Run the following in a new terminal window. This process is the most fun if you can see this and the previous terminal (which is consuming the raw ratings) at the same time. If your terminal program lets you do horizontal split panes, try it that way:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/console-producer-ratings.sh %}</code></pre>

  <p>When the producer starts up, copy and paste these lines into the terminal:</p>
  <pre class="snippet"><code class="json">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/ratings.json %}</code></pre>

  <p>Speaking of that consumer terminal, these are the results you should see there if you paste in all the movies and ratings as shown in this recipe:</p>
  <pre class="snippet"><code class="json">{% include_raw recipes/tumbling-windows/kstreams/code/recipe-steps/dev/outputs/windowed-counted-ratings.json %}</code></pre>

  <p>You have now computed an aggregation over a tumbling window! Well done.</p>

</div>
