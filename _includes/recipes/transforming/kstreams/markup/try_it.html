<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">1. Get Confluent Platform</h4>

  <p>If you haven't already, get Confluent Platform.</p>
  <pre class="snippet"><code class="shell">{% include shared-content/docker-install.txt %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">2. Initialize the project</h4>

  <p>To get started, make a new directory anywhere you'd like for this project:</p>
  <pre class="snippet"><code class="shell">mkdir transform-stream && cd transform-stream</code></pre>

  <p>Then create the following Gradle build file, named <code>build.gradle</code> for the project:</p>
  <pre class="snippet"><code class="groovy">{% include_raw recipes/transforming/kstreams/code/build.gradle %}</code></pre>

  <p>Next, create a directory for configuration data:</p>
  <pre class="snippet"><code class="shell">mkdir configuration</code></pre>

  <p>Then create a development file at <code>configuration/dev.properties</code>:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/transforming/kstreams/code/configuration/dev.properties %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">3. Create a schema for the events</h4>

  <p>Create a directory for the schemas that represent the events in the stream:</p>
  <pre class="snippet"><code class="shell">mkdir -p src/main/avro</code></pre>

  <p>Then create the following Avro schema file at <code>src/main/avro/input_movie_event.avsc</code> for the raw movies:</p>
  <pre class="snippet"><code class="avro">{% include_raw recipes/transforming/kstreams/code/src/main/avro/input_movie_event.avsc %}</code></pre>

  <p>While you're at it, create another Avro schema file at <code>src/main/avro/parsed_movies.avsc</code> for the transformed movies:</p>
  <pre class="snippet"><code class="avro">{% include_raw recipes/transforming/kstreams/code/src/main/avro/parsed_movies.avsc %}</code></pre>

  <p>Because we will use this Avro schema in our Java code, we'll need to compile it. The Gradle Avro plugin is a part of the build, so it will see your new Avro files, generate Java code for them, and compile those and all other Java sources. Run this command to get it all done:</p>
  <pre class="snippet"><code class="shell">gradlew build</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">4. Create the Kafka Streams topology</h4>

  <p>Create a directory for the Java files in this project:</p>
  <pre class="snippet"><code class="shell">mkdir -p src/main/java/io/confluent/developer</code></pre>

  <p>Then create the following file at <code>src/main/java/io/confluent/developer/TransformStream.java</code>. Let's take a close look at the <code>buildTopology()</code> method, which uses the Kafka Streams DSL.</p>

  <p>The first thing the method does is create an instance of <code>StreamsBuilder</code>, which is the helper object that lets us build our topology. Next we call the <code>stream()</code> method, which creates a <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KStream.html">KStream</a></code> object (called <code>rawMovies</code> in this case) out of an underlying Kafka topic. Note the type of that stream is <code>Long, RawMovie</code>, because the topic contains the raw movie objects we want to transform. RawMovie's <code>title</code> field contains the title and the release year together, which we want to make into separate fields in a new object.</p>

  <p>We get that transforming work done with the next line, which is a call to the <code><a href="https://kafka.apache.org/{{ site.ak_javadoc_version }}/javadoc/org/apache/kafka/streams/kstream/KStream.html#map-org.apache.kafka.streams.kstream.KeyValueMapper-">map()</a></code> method. <code>map()</code> takes each input record and creates a new stream with transformed records in it. Its parameter is a single Java Lambda that takes the input key and value and returns an instance of the <code>KeyValue</code> class with the new record in it. This does two things. First, it rekeys the incoming stream, using the <code>movieId</code> as the key. We don't absolutely need to do that to accomplish the transformation, but it's easy enough to do at the same time, and it sets a useful key on the output stream, which is generally a good idea. Second, it calls the <code>convertRawMovie()</code> method to turn the <code>RawMovie</code> value into a <code>Movie</code>. This is the essence of the transformation. The <code>convertRawMovie()</code> method contains the sort of unpleasant string parsing that is a part of many stream processing pipelines, which we are happily able to encapsulate in a single, easily testable method. Any further stages we might build in the pipeline after this point are blissfully unaware that we ever had a string to parse in the first place.

  <p>Moreover, it's worth noting that we're calling <code>map()</code> and not <code>mapValues()</code></p>

  <pre class="snippet"><code class="java">{% include_raw recipes/transforming/kstreams/code/src/main/java/io/confluent/developer/TransformStream.java %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">5. Compile and run the Kafka Streams program</h4>

  <p>In your terminal, run:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/transforming/kstreams/harness/recipe-steps/dev/build-uberjar.sh %}</code></pre>

  <p>Now that an uberjar for the Kafka Streams application has been built, you can launch it locally. When you run the following, the prompt won't return, because the application will run until you exit it:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/transforming/kstreams/harness/recipe-steps/dev/run-dev-app.sh %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">6. Produce events to the input topic</h4>

  <p>In a new terminal, run:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/transforming/kstreams/harness/recipe-steps/dev/console-producer.sh %}</code></pre>

  <p>When the console producer starts, it will log some messages and hang, waiting for your input. Type in one line at a time and press enter to send it. Each line represents an event. To send all of the events below, paste the following into the prompt and press enter:</p>
  <pre class="snippet"><code class="json">{% include_raw recipes/transforming/kstreams/harness/recipe-steps/dev/input-events.json %}</code></pre>
</div>

<div class="recipe-try-it-step">
  <h4 class="subtitle is-4">7. Observe the transformed movies in the output topic</h4>

  <p>Leave your original terminal running. To consume the events produced by your Streams application you'll need another terminal open. </p>

  <p>First, to consume the events of drama films, run the following:</p>
  <pre class="snippet"><code class="shell">{% include_raw recipes/transforming/kstreams/harness/recipe-steps/dev/console-consumer.sh %}</code></pre>

  <p>This should yield the following messages:</p>
  <pre class="snippet"><code class="json">{% include_raw recipes/transforming/kstreams/harness/recipe-steps/dev/outputs/actual-movies.json %}</code></pre>

</div>
